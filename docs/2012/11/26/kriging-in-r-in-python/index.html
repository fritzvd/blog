<!doctype html>







<html
  class="not-ready lg:text-base"
  style="--bg:#faf8f1"
  lang="en-us"
  dir="ltr"
><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, shrink-to-fit=no"
  />

  
  <title>Kriging in R in Python - fritzvd</title>

  
  <meta name="theme-color" />

  <meta name="description" content="This might be a repost of some sort. However I found that it was kind of hard to find anything about this specific topic. So here it goes.
Kriging is a geostatistical method to be able translate point data to a grid, to find out where you can predict stuff really well and where the variance is really high. As always GIGO (garbage in garbage out). But it is at least a large improvement from interpolation techniques such as Inversed Distance Weighting (IDW) which is often implemented in GIS software." />
  <meta name="author" content="fritzvd" /><link rel="preload stylesheet" as="style" href="https://fritzvd.com/blog/main.min.css" />

  
  <link rel="preload" as="image" href="https://fritzvd.com/blog/theme.png" />

  

  

  <script
    defer
    src="https://fritzvd.com/blog/highlight.min.js"
    onload="hljs.initHighlightingOnLoad();"
  ></script>

  
  <link
    rel="icon"
    href="https://fritzvd.com/blog/favicon.ico"
  />
  <link
    rel="apple-touch-icon"
    href="https://fritzvd.com/blog/apple-touch-icon.png"
  />

  <meta name="generator" content="Hugo 0.105.0"><meta itemprop="name" content="Kriging in R in Python">
<meta itemprop="description" content="This might be a repost of some sort. However I found that it was kind of hard to find anything about this specific topic. So here it goes.
Kriging is a geostatistical method to be able translate point data to a grid, to find out where you can predict stuff really well and where the variance is really high. As always GIGO (garbage in garbage out). But it is at least a large improvement from interpolation techniques such as Inversed Distance Weighting (IDW) which is often implemented in GIS software."><meta itemprop="datePublished" content="2012-11-26T13:48:56+00:00" />
<meta itemprop="dateModified" content="2012-11-26T13:48:56+00:00" />
<meta itemprop="wordCount" content="699">
<meta itemprop="keywords" content="rpy2 rpy r python kriging gstat," /><meta property="og:title" content="Kriging in R in Python" />
<meta property="og:description" content="This might be a repost of some sort. However I found that it was kind of hard to find anything about this specific topic. So here it goes.
Kriging is a geostatistical method to be able translate point data to a grid, to find out where you can predict stuff really well and where the variance is really high. As always GIGO (garbage in garbage out). But it is at least a large improvement from interpolation techniques such as Inversed Distance Weighting (IDW) which is often implemented in GIS software." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://fritzvd.com/blog/2012/11/26/kriging-in-r-in-python/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2012-11-26T13:48:56+00:00" />
<meta property="article:modified_time" content="2012-11-26T13:48:56+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Kriging in R in Python"/>
<meta name="twitter:description" content="This might be a repost of some sort. However I found that it was kind of hard to find anything about this specific topic. So here it goes.
Kriging is a geostatistical method to be able translate point data to a grid, to find out where you can predict stuff really well and where the variance is really high. As always GIGO (garbage in garbage out). But it is at least a large improvement from interpolation techniques such as Inversed Distance Weighting (IDW) which is often implemented in GIS software."/>

  <link rel="canonical" href="https://fritzvd.com/blog/2012/11/26/kriging-in-r-in-python/" />
</head>
<body
    class="bg-(--bg) text-black antialiased duration-200 ease-out [-webkit-tap-highlight-color:transparent] dark:text-white"
  ><header
  class="mx-auto flex h-[4.5rem] max-w-(--w) px-8 whitespace-nowrap lg:justify-center"
>
  <div class="relative z-50 flex items-center ltr:mr-auto rtl:ml-auto">
    <a
      class="-translate-y-[1px] text-2xl font-medium"
      href="https://fritzvd.com/blog/"
      >fritzvd</a
    >
    <div
      class="btn-dark text-[0px] ltr:ml-4 rtl:mr-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]"
      role="button"
      aria-label="Dark"
    ></div>
  </div>

  <div
    class="btn-menu relative z-50 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden ltr:-mr-8 rtl:-ml-8"
    role="button"
    aria-label="Menu"
  ></div>

  <script>
    
    const htmlClass = document.documentElement.classList;
    setTimeout(() => {
      htmlClass.remove('not-ready');
    }, 10);

    
    const btnMenu = document.querySelector('.btn-menu');
    btnMenu.addEventListener('click', () => {
      htmlClass.toggle('open');
    });

    
    const metaTheme = document.querySelector('meta[name="theme-color"]');
    const lightBg = '#faf8f1'.replace(/"/g, '');
    const setDark = (isDark) => {
      metaTheme.setAttribute('content', isDark ? '#000' : lightBg);
      htmlClass[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark);
    };

    
    const darkScheme = window.matchMedia('(prefers-color-scheme: dark)');
    if (htmlClass.contains('dark')) {
      setDark(true);
    } else {
      const darkVal = localStorage.getItem('dark');
      setDark(darkVal ? darkVal === 'true' : darkScheme.matches);
    }

    
    darkScheme.addEventListener('change', (event) => {
      setDark(event.matches);
    });

    
    const btnDark = document.querySelector('.btn-dark');
    btnDark.addEventListener('click', () => {
      setDark(localStorage.getItem('dark') !== 'true');
    });
  </script>

  <div
    class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full flex-col justify-center bg-(--bg) pb-16 duration-200 select-none lg:static lg:h-auto lg:flex-row lg:bg-transparent! lg:pb-0 lg:transition-none"
  >
  </div>
</header>
<main
      class="prose prose-neutral dark:prose-invert relative mx-auto min-h-[calc(100vh-9rem)] max-w-(--w) px-8 pt-14 pb-16"
    ><article>
  <header class="mb-14">
    <h1 class="my-0! pb-2.5">Kriging in R in Python</h1><div class="text-xs antialiased opacity-60"><time>Nov 26, 2012</time><span class="mx-1">&middot;</span>
      <span>fritzvd</span></div></header>

  <section><p>This might be a repost of some sort. However I found that it was kind of hard to find anything about this specific topic. So here it goes.</p>
<p>Kriging is a geostatistical method to be able translate point data to a grid, to find out where you can predict stuff really well and where the variance is really high. As always GIGO (garbage in garbage out). But it is at least a large improvement from interpolation techniques such as Inversed Distance Weighting (IDW) which is often implemented in GIS software.</p>
<p>However for Kriging you need a bit more information. You need to input a variogram. This is however often estimated with ‘expert’ knowledge and looking at graphs produced by the input data. In my mind this sounds like automatable. But I haven’t got around to it.</p>
<p>The best implementations exist for R, but for those who don’t like R for any reason (slow, not really productionable etc.) there is a Python implementation by Ambhas <a href="http://www.ambhas.com/tools/html/krige_8py_source.html" title="kriging in python">right here</a>.</p>
<p>For those who don’t care. You can use r in python with rpy2 (or rpy). This is a bit ugly. But it is at least a lot nicer (imho) to work with (data i/o) using gdal etc) in production. Also anything beyond Ordinary Kriging becomes complex. And I did not find anyone yet publishing their code for non-ordinary kriging (cokriging, colocated cokriging and other more complicated algorithms). If anyone comes around to writing it, please open source that shiznit.</p>
<p>Anyways. If you want to do colocated cokriging you have to have 2 forms of data for every point. The code will look like this:</p>
<pre><code class="syntax python">def cokriging_in_r(self, x, y, z):
        '''
        Cokriging (and ordinary kriging) is quite fast in R.
        This would anyway be more pragmatic than rewriting/porting it to Python.
        For the moment this will be the 'best' way as R makes it very easy to
        use kriging without fitting a variogram model, but using a standard 
        variogram.
        '''
        import rpy2
        import rpy2.robjects as robj
        import time
        time0 = time.time()
        robj.r.library('gstat')
        self.create_interpolation_grid()
        xi, yi = robj.FloatVector(self.xi.tolist()), robj.FloatVector(self.yi.tolist())
        dataset = self.dataloader.dataset.ReadAsArray().flatten()
        mask = numpy.equal(dataset, -9999)
        rxi = robj.FloatVector(dataset.tolist())
        secondary = self.get_secondary_for_locations()
        secondary = robj.FloatVector(secondary)
        x,y,z = robj.FloatVector(x), robj.FloatVector(y), robj.FloatVector(z)
        primary_frame = robj.DataFrame({'x': x, 'y': y, 'z':z})
        secondary_frame = robj.DataFrame({'x': xi, 'y': yi, 'secondary': rxi})
        target_frame = robj.DataFrame({'x':xi, 'y':yi})
        vgm_args = {'model_type': 'Sph', 'range1': 20000, 'range2':1040000}
        # following command gives a python output to r functions
        vgm_args['nugget'] = 0.035
        vgm_args['sill1'] = 0.473
        vgm_args['sill2'] = 8.994
        secondary_variance = dataset[~mask].var()
        primary_variance = robj.r.var(z)[0]
        correlation_secondary_primary = numpy.abs(robj.r.cor(z, secondary))
        variance_correction = numpy.sqrt(primary_variance * secondary_variance)
        # The cross coefficient is used in the cross variogram (crossgram)
        # 
        cross_coef = (correlation_secondary_primary * variance_correction)[0]
        # change it back to rpy strict

        # The variogram is combined. This is a bit awkward in Rpy.
        # So one way is change the args manually (see below)
        # or load variables in R before hand.
        variogram_secondary = robj.r.vgm(vgm_args['sill1'] * secondary_variance, 
            vgm_args['model_type'], vgm_args['range1'], vgm_args['nugget'], 
            robj.r("add.to=vgm("+ str(vgm_args['sill2'] * secondary_variance)
                + ", 'Sph', 1040000, " + str(vgm_args['nugget'] * 
                    secondary_variance)+")"))
        variogram_primary = robj.r.vgm(vgm_args['sill1'] * primary_variance,
            vgm_args['model_type'], vgm_args['range1'], vgm_args['nugget'], 
            robj.r("add.to=vgm("+ str(vgm_args['sill2'] * primary_variance)
                + ", 'Sph', 1040000, " + str(vgm_args['nugget'] * 
                    primary_variance)+")"))
        crossgram = robj.r.vgm(vgm_args['sill1'] * cross_coef, 
            vgm_args['model_type'], vgm_args['range1'], vgm_args['nugget'], 
            robj.r("add.to=vgm("+ str(vgm_args['sill2'] * cross_coef)
                + ", 'Sph', 1040000, " + str(vgm_args['nugget'] * cross_coef) + ")"))

        cck = robj.r('NULL')
        cck = robj.r.gstat(cck, "primary", robj.r('z ~ 1'), robj.r('~ x + y'), 
            data=primary_frame, model=variogram_primary, nmax=40)
        cck = robj.r.gstat(cck, "secondary", robj.r('secondary~ 1'), robj.r('~ x + y'),
            data=secondary_frame, model=variogram_secondary, 
            merge=robj.r("c('primary','secondary')"), nmax=1)
        cck = robj.r.gstat(cck, robj.r('c("primary", "secondary")'), model=crossgram, nmax=40) 
        result = robj.r.predict(cck, target_frame)
        # crossval = robj.r('gstat.cv')(cck)
        time1 = time.time()
        deltatime = time1-time0
        print('Kriging took '+ str(deltatime) + ' seconds')
        secondary_est = numpy.array(result[4])
        secondary_est = secondary_est.reshape((self.ny, self.nx))
        primary_est = numpy.array(result[2])
        primary_est = primary_est.reshape((self.ny, self.nx))
        return secondary_est, primary_est
</code></pre>
<p>The <code>create_interpolation_grid</code> refers to a function which sets up an empty grid based on the extent of the grid and the size of the pixels:</p>
<pre><code class="syntax python">def create_interpolation_grid(self):
        '''
        Run this to get some basic stuff, like an empty grid to interpolated
        the data to, the extent and size of the tifs.
        '''
        extent = dataset.extent
        self.nx, self.ny = basegrid.size
        xi = numpy.linspace(extent[0], extent[1], self.nx)
        yi = numpy.linspace(extent[2], extent[3], self.ny)
        xi, yi = numpy.meshgrid(xi, yi)
        self.xi, self.yi = xi.flatten(), yi.flatten()
</code></pre><blockquote>
</blockquote>
</section>

  <footer class="mt-12 flex flex-wrap"><a
      class="mb-1.5 rounded-lg bg-black/[3%] px-5 py-1 no-underline hover:bg-black/[6%] ltr:mr-1.5 rtl:ml-1.5 dark:bg-white/[8%] dark:hover:bg-white/[12%]"
      href="https://fritzvd.com/blog/tags/rpy2-rpy-r-python-kriging-gstat"
      >rpy2 rpy r python kriging gstat</a
    ></footer><nav
    class="mt-24 flex overflow-hidden rounded-xl bg-black/[3%] text-lg leading-[1.2]! *:flex *:w-1/2 *:items-center *:p-5 *:font-medium *:no-underline dark:bg-white/[8%] [&>*:hover]:bg-black/[2%] dark:[&>*:hover]:bg-white/[3%]"
  ><a class="ltr:pr-3 rtl:pl-3" href="https://fritzvd.com/blog/2012/11/28/making-sure-gdal-works-with-ecw-libecw-under-linux/"
      ><span class="ltr:mr-1.5 rtl:ml-1.5">←</span><span>Making sure GDAL works with ECW libecw under linux</span></a
    ><a
      class="justify-end pl-3 ltr:ml-auto rtl:mr-auto"
      href="https://fritzvd.com/blog/2012/02/04/snow/"
      ><span>Snow</span><span class="ltr:ml-1.5 rtl:mr-1.5">→</span></a
    ></nav></article></main><footer
  class="mx-auto flex h-[4.5rem] max-w-(--w) items-center px-8 text-xs tracking-wider uppercase opacity-60"
>
  <div class="mr-auto">&copy;2025
    <a class="link" href="https://fritzvd.com/blog/">fritzvd</a></div>
  <a class="link mx-6" href="https://gohugo.io/" rel="noopener" target="_blank"
    >powered by hugo️️</a
  >️
  <a
    class="link"
    href="https://github.com/nanxiaobei/hugo-paper"
    rel="noopener"
    target="_blank"
    >hugo-paper</a
  >
</footer>
</body>
</html>
